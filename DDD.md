# DDD勉強

### Layered Architechture (DDD本)
- UI
	- 情報表示・ユーザーのアクションの解釈
- Application
	- 指示の理解(XML/JSON解釈など)・ドメインへの通知
	- 薄く保たれなければならない。
- Domain
	- ビジネスロジック
- Infrastructure
	- 永続化など
- 同じか下方向のレイアにしか依存してはいけない。

### 値オブジェクト ([Youtube](https://www.youtube.com/watch?v=1OgvUIsv96o))
- Stringly Typed code => Strongly Typed code
- emailをただ文字列として扱うと、それが本当に正しいメアドなのかを都度バリデーションしないといけない。Emailオブジェクトとして受け渡しすれば、Emailオブジェクトが定義したメアドを都度、呼び出すだけでOK！

- ドメインイベント
	- 処理が終わったあとに、別のことしたいみたいなことが後からあるかもしれない。普通にやると、そのコードを触らずに実装することはできない。でも何かした後、イベントを発火しておけば、その後に処理したいものはそれを購読しておけば、いくらでも外で実装ができる。
	- 購入がcompleteした後に、期間限定のポイントを付加したい場合、'complete'みたいなeventをpublishして、それをsubscribeしてポイント付加を実装すればいい。complete処理は一切触らなくていい。

### サービス 
(DDD本)

- 優れたサービスの条件
	1. 操作がドメインの概念に関係しており、その概念がエンティティや値オブジェクトの自然な一部ではない
	2. ドメインモデルの他の要素の観点からインターフェースが定義されている。
	3. 操作に状態がない
- 実態よりも活動、名詞よりも動詞。
- 操作名はユビキタス言語
- 節度をもって適応すべきで、エンティティ・値オブジェクトから全てのふるまいを奪ってはいけない。

([DDD難民に捧げる Domain-Driven Designのエッセンス](https://www.ogis-ri.co.jp/otc/hiroba/technical/DDDEssence/chap2.html))

- ドメインで扱う概念の中には、1つの機能や処理が単体で存在していて、もの（オブジェクト）として扱うのが不自然なものもある。そうしたものは、サービスという形でユビキタス言語に組み込む。サービスは基本的に状態をもたない（stateless）。

### ファクトリ

- オブジェクトや集約の生成処理はそれ自体複雑になりうるため、ファクトリを導入して生成処理をカプセル化*2する。オブジェクトの生成そのものがドメインモデル上で重要な意味をもつことは（ほとんど）ないため、ファクトリはドメインモデルの一部ではない。あくまで、ドメインの設計上必要な一要素、という位置付けになる。

### レポジトリ ([レイヤー設計とか、オブジェクト指向とか、DDDとか、その辺](http://mattun.hatenablog.com/entry/2014/07/19/135320))
- DBへの永続化や問い合わせ処理の複雑さによって、ドメインモデルが汚染されないようにするため、リポジトリという永続化／問い合わせ専用オブジェクトをドメイン設計に導入する
- コントローラからはRepositoryを呼んではいけない、っていうのがある。（これは海外でもあるっぽい。）代わりにServiceを呼ぶべきであると。
- そもそも、ドメインオブジェクトのインタラクションはServiceLayerに委譲するので、Repositoryどころか、他のEntityの振舞いとかドメイン層の振舞いはどれもやってはいけないはず。コントローラの役割はServiceLayerの結果をビューに渡すなどの処理のみしか許されていない。
- ServiceがDDDにあるような1ドメインモデルとしてのServieならRepository禁止はDAOと混同しているからで、純粋なドメインモデルとしてのRepositoryはコントローラで呼んでもいいはず。Serviceをかぶせることを強制してしまうと、それこそ、どこで何をやっているのか分からなくなる。
- 一般的なEntity問い合わせの責務はRepositoryに集約されるべき。

([DDD の Java EE 実装サンプル - Cargo Tracker を読み解く](http://qiita.com/opengl-8080/items/4f8938c65d8a2b7e50d0))

- 「アプリケーション層は薄く保つ」「ドメインの知識が漏れている」
- アプリケーション層の目的は「ドメインオブジェクトを連携させて処理を実現する」こと

([dont use dao use repository](https://thinkinginobjects.com/2012/08/26/dont-use-dao-use-repository/))

-  You avoid to expose the type of Accounts identity to the Repository interface. It makes my life easy

(DDD本)

-  クライアントは求めるものをモデルの用語で要求する (Respository.forTrackingId(string))
-  返却値はcountなどの計算した後の結果が返ることもある
-  トランザクション制御をクライアントに委ねること
-  